---
layout: post
title: "알고리즘 대회에 필요한 수학"
date: 2022-08-17 10:35:29 +0900
categories: [Code-Test, Algorithm]
tags: [algorithm, math]
---
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


출처: [알고리즘 대회에 필요한 수학](https://algospot.com/wiki/read/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%8C%80%ED%9A%8C%EC%97%90_%ED%95%84%EC%9A%94%ED%95%9C_%EC%88%98%ED%95%99)

<div class="article-container">

						<!-- Article Header -->
						<header>
							<h2>
	알고리즘 대회에 필요한 수학
</h2>
							<!-- Article Header Tab Navigation -->
							
	<nav>
		<ul class="tab-switch">
			<li>
				<a class="default-tab current" href="http://en.wikipedia.org/wiki/read/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%8C%80%ED%9A%8C%EC%97%90_%ED%95%84%EC%9A%94%ED%95%9C_%EC%88%98%ED%95%99" rel="tooltip" title="Read article">
					읽기
				</a>
			</li>
			<li>
				<a class="" href="http://en.wikipedia.org/wiki/edit/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%8C%80%ED%9A%8C%EC%97%90_%ED%95%84%EC%9A%94%ED%95%9C_%EC%88%98%ED%95%99" rel="tooltip" title="Edit article">
				편집하기
				</a>
			</li>
			<li>
				<a class="" href="http://en.wikipedia.org/wiki/history/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EB%8C%80%ED%9A%8C%EC%97%90_%ED%95%84%EC%9A%94%ED%95%9C_%EC%88%98%ED%95%99" rel="tooltip" title="See article history">
					편집 내역
				</a>
			</li>
		</ul>
	</nav>

							<!-- /Article Header Tab Navigation -->
						</header>
						<!-- /Article Header -->

						<!-- Article Content -->
						 
	<section>
		<div class="wiki-text">
			<h2 id="toc_0">이산 수학</h2>

<h3 id="toc_1">점화식 풀이 기법들</h3>

<ul>
<li>2차 선형동차점화식 (Linear homogenous recurrence)

<ul>
<li>다음과 같은 형태: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-1-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi></mrow></msub><mo>=</mo><mi>α</mi><mo>⋅</mo><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>β</mi><mo>⋅</mo><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{k} = \alpha \cdot a_{k-1} + \beta \cdot a_{k-2}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-1">a_{k} = \alpha \cdot a_{k-1} + \beta \cdot a_{k-2}</script>. </li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-2-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msub><mo>=</mo><msup><mi>r</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">a_{n}=r^{n}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-2">a_{n}=r^{n}</script> 꼴이라고 생각하고 대입해 보면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-3-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msup><mo>−</mo><mi>α</mi><mo>⋅</mo><mi>r</mi><mo>−</mo><mi>β</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">r^{2} - \alpha\cdot r - \beta = 0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-3">r^{2} - \alpha\cdot r - \beta = 0</script>을 얻는다. 이 방정식의 해 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-4-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-4">r</script>에 대해 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-5-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">r^{n}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-5">r^{n}</script>은 해가 됨. </li>
<li>해가 둘 있을 경우, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-6-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⋅</mo><msubsup><mi>r</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mo>+</mo><mi>b</mi><mo>⋅</mo><msubsup><mi>r</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">a\cdot r_{1}^{n} + b\cdot r_{2}^{n}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-6">a\cdot r_{1}^{n} + b\cdot r_{2}^{n}</script> 꼴의 선형 결합도 해가 된다 (당연). 이 계수들을 초기상태에 맞도록 지정.</li>
<li>Application:

<ul>
<li>피보나치 수열의 일반항은?</li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-7-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-7">p</script>의 확률로 이기는 bet을 한다. (승-패)가 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-8-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-8">W</script>가 되거나 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-9-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">-L</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-9">-L</script>이 될 때까지 하는데, 이 때 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-10-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-10">W</script> 승으로 끝날 확률은? (ICPC WF '13 B)</li>
</ul></li>
<li>일반화: 3차, 4차, 5차.. 라도 같은 요령으로 풀 수 있다 (3차, 4차 방정식을 풀기 힘들어서 그렇지)

<ul>
<li>중근이면 어떻게? 만약 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-11-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-11">r</script>이 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-12-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-12">m+1</script>번 중근으로 등장한다면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-13-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msup><mo>,</mo><mi>n</mi><mo>⋅</mo><msup><mi>r</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msup><mo>,</mo><mo>⋯</mo><mo>,</mo><msup><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi></mrow></msup><mo>⋅</mo><msup><mi>r</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">r^{n}, n\cdot r^{n}, \cdots, n^{m}\cdot r^{n}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-13">r^{n}, n\cdot r^{n}, \cdots, n^{m}\cdot r^{n}</script> 의 선형결합이 들어간다.</li>
</ul></li>
</ul></li>
<li><p>선형비동차점화식 (Linear non-homogenous recurrence)</p>

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-14-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>α</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>α</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>−</mo><mi>n</mi></mrow></msub><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>−</mo><mi>n</mi></mrow></msub><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_{k} = \alpha_{k-1}a_{k-1} + \cdots + \alpha_{k-n}a_{k-n} + f(n)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-14">a_{k} = \alpha_{k-1}a_{k-1} + \cdots + \alpha_{k-n}a_{k-n} + f(n)</script> (마지막의 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-15-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-15">f(n)</script>에 주의!)</li>
<li>해법

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-16-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><msub><mi>b</mi><mi>n</mi></msub><mo>+</mo><msub><mi>h</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n = b_n + h_n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-16">a_n = b_n + h_n</script>으로 분해 (<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-17-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-17">b_n</script>은 점화식만 만족하고 초기상태는 만족하지 않는 답. 대개 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-18-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-18">f(n)</script>과 비슷한 형태를 갖는다.</li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-19-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">h_n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-19">h_n</script>을 찾고 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-20-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-20">a_n</script>의 계수를 초기상태 성립하도록 맞춰 주면 됨.</li>
</ul></li>
</ul></li>
<li><p><a href="http://www.eecs.yorku.ca/course_archive/2008-09/S/1019/Website_files/21-linear-recurrences.pdf">간단한 정리</a></p></li>
<li><p>일반항 계산을 직접 하는 경우도 있지만 행렬의 형태로 표현하고 푸는 일이 많다.</p>

<ul>
<li>예) 피보나치 수열의 n번째 수를 구하기 위해서는
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-21-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>[</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><msub><mi>F</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><msub><mi>F</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd></mtr></mtable><mo>]</mo></mrow><mo>=</mo><mrow><mo>(</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>1</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow><mrow><mo>[</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><msub><mi>F</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><msub><mi>F</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msub></mtd></mtr></mtable><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
F_{n+2} \\
F_{n+1}
\end{bmatrix}
=
\begin{pmatrix}
1 &amp; 1\\
1 &amp; 0
\end{pmatrix}
\begin{bmatrix}
F_{n+1} \\
F_{n}
\end{bmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-21">
\begin{bmatrix}
F_{n+2} \\
F_{n+1}
\end{bmatrix}
=
\begin{pmatrix}
1 & 1\\
1 & 0
\end{pmatrix}
\begin{bmatrix}
F_{n+1} \\
F_{n}
\end{bmatrix}
</script>
의 점화식으로부터 얻는 다음의 식을 이용해 계산한다.
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-22-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo>(</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>1</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow><mi>n</mi></msup><mrow><mo>[</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>0</mn></mtd></mtr></mtable><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix}
1 &amp; 1\\
1 &amp; 0
\end{pmatrix}^n
\begin{bmatrix}
1 \\
0
\end{bmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-22">
\begin{pmatrix}
1 & 1\\
1 & 0
\end{pmatrix}^n
\begin{bmatrix}
1 \\
0
\end{bmatrix}
</script></li>
</ul></li>
</ul>

<h3 id="toc_2">이항계수와 숫자 세기</h3>

<ul>
<li>이항계수 (Binomial coefficient): <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-23-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>C</mi><mi>r</mi><mo>=</mo><mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>r</mi></mfrac><mo>)</mo></mrow><mo>=</mo><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo stretchy="false">)</mo><mo>!</mo><mi>r</mi><mo>!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">nCr = \left ( n \atop r \right ) = \frac{n!}{(n-r)!r!}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-23">nCr = \left ( n \atop r \right ) = \frac{n!}{(n-r)!r!}</script>

<ul>
<li>점화식: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-24-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>r</mi></mfrac><mo>)</mo></mrow><mo>=</mo><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>)</mo></mrow><mo>+</mo><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mi>r</mi></mfrac><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\left( n \atop r \right ) = \left( n-1 \atop r-1 \right) + \left( n-1 \atop r \right)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-24">\left( n \atop r \right ) = \left( n-1 \atop r-1 \right) + \left( n-1 \atop r \right)</script></li>
<li>Identity: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-25-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mn>0</mn></mfrac><mo>)</mo></mrow><mo>=</mo><mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>n</mi></mfrac><mo>)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\left( n \atop 0 \right ) = \left ( n \atop n \right ) = 1</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-25">\left( n \atop 0 \right ) = \left ( n \atop n \right ) = 1</script>, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-26-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></munderover><mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>i</mi></mfrac><mo>)</mo></mrow><mo>=</mo><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{n}\left(n \atop i\right) = 2^{n}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-26">\sum_{i=0}^{n}\left(n \atop i\right) = 2^{n}</script>.</li>
</ul></li>
<li>이항계수를 이용해 순열 수 세기: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-27-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-27">n</script>개의 원소 중에서 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-28-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-28">r</script>개를 뽑을 수 있는 경우의 수는?

<ul>
<li>유의해야 할 것

<ul>
<li>중복 여부: 같은 원소를 두 번 뽑을 수 있는가?</li>
<li>순서 여부: 같은 원소를 순서만 다르게 뽑았으면 다른 경우로 치는가?</li>
</ul></li>
<li>공식

<ul>
<li>중복 없이, 순서 있을 때: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-29-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo>=</mo><mi>n</mi><mi>P</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">\frac{n!}{(n-r)!} = nPr</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-29">\frac{n!}{(n-r)!} = nPr</script></li>
<li>중복 있고, 순서 있을 때: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-30-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mi>r</mi></mrow></msup></mrow><annotation encoding="application/x-tex">n^{r}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-30">n^{r}</script></li>
<li>중복 없이, 순서 없을 때: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-31-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>r</mi></mfrac><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\left ( n \atop r \right)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-31">\left ( n \atop r \right)</script></li>
<li>중복 있고, 순서 없을 때: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-32-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mi>n</mi><mo>+</mo><mi>r</mi><mo>−</mo><mn>1</mn></mrow><mi>r</mi></mfrac><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\left ( n + r - 1 \atop r \right )</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-32">\left ( n + r - 1 \atop r \right )</script> (<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-33-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-33">n</script>개의 원소와 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-34-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r-1</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-34">r-1</script>개의 막대기를 내려놓는 방법의 수)</li>
</ul></li>
</ul></li>
<li><a href="http://en.wikipedia.org/wiki/Catalan_number">카탈란 수</a>: 다양한 문제의 답이 된다.

<ul>
<li><a href="http://en.wikipedia.org/wiki/Catalan_number#Applications_in_combinatorics">예제 문제들</a>: 길이가 2n인 괄호 수식의 수, n+1개의 리프를 가진 풀 바이너리 트리의 수, etc.</li>
<li>수식: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-35-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>n</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mrow><mo>(</mo><mfrac linethickness="0"><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></mfrac><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">C_n = \frac{1}{n+1} \left( 2n \atop n \right )</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-35">C_n = \frac{1}{n+1} \left( 2n \atop n \right )</script></li>
</ul></li>
<li><a href="http://en.wikipedia.org/wiki/Multinomial_theorem#Multinomial_coefficients">Multinomial coefficient</a></li>
<li><a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=combinatorics">탑코더 튜토리얼</a></li>
</ul>

<h3 id="toc_3"><a href="http://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle">포함-배제 법칙</a></h3>

<ul>
<li>교집합이 있는 n개의 집합의 합집합의 크기를 구하려면:

<ul>
<li>각 집합의 크기를 모두 더한다.</li>
<li>각 2개 집합에 대해 교집합의 크기를 모두 뺀다.</li>
<li>각 3개 집합에 대해 교집합의 크기를 모두 더한다.</li>
<li>...</li>
</ul></li>
<li><a href="http://apps.topcoder.com/forums/?module=Thread&amp;threadID=685138&amp;start=0&amp;mc=2#1279067">탑코더 튜토리얼</a></li>
<li>Application: <a href="http://en.wikipedia.org/wiki/Derangement">Derangement</a> 계산하기 - n개의 원소를 섞되, 그 중 아무 것도 원래 위치에 있지 않는 경우의 수는?

<ul>
<li>Let: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-36-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-36">A_i</script> = <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-37-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-37">i</script>가 제 자리로 간 순열의 개수. </li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-38-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></munderover><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mo>−</mo><mi>i</mi></mrow></msup><mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>i</mi></mfrac><mo>)</mo></mrow><mi>i</mi><mo>!</mo></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{n}(-1)^{n-i}\left( n \atop i \right)i!</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-38">\sum_{i=0}^{n}(-1)^{n-i}\left( n \atop i \right)i!</script></li>
</ul></li>
<li><a href="http://en.wikipedia.org/wiki/M%C3%B6bius_inversion_formula">Moebius 함수와 반전 공식</a> - 약수/배수 관계를 이용한 포함-배제 법칙이 필요한 경우 이 함수로 답이 나타날 수 있다.

<ul>
<li>n 이하의 Square Free 개수 세기 - <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-39-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>∈</mo><msup><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="double-struck">Z</mi></mrow><mo>+</mo></msup></mrow></munder><mi>μ</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo fence="false" stretchy="false">⌊</mo><mfrac><mi>n</mi><msup><mi>i</mi><mn>2</mn></msup></mfrac><mo fence="false" stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\sum_{i \in \Bbb{Z}^+} \mu (i) \lfloor \frac{n}{i^2} \rfloor</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-39">\sum_{i \in \Bbb{Z}^+} \mu (i) \lfloor \frac{n}{i^2} \rfloor </script>가 답이 된다. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-40-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-40">\sqrt{n}</script>까지만 계산해주면 원하는 개수가 나온다.</li>
</ul></li>
</ul>

<h3 id="toc_4"><a href="http://en.wikipedia.org/wiki/Burnside's_lemma">번사이드 정리</a></h3>

<ul>
<li><a href="http://petr-mitrichev.blogspot.kr/2008/11/burnsides-lemma.html">페트르님의 정리</a></li>
<li>경우의 수를 세는데, 특정 transform operation(회전, 반사, ..)해서 같은 경우들은 하나로 친다. 전체 경우의 수는?

<ol>
<li>각 operation마다 이 operation을 했을 때 변하지 않는 경우의 수를 센다 (단, "아무것도 하지 않는다"라는 operation도 있어야 함!)</li>
<li>전체 경우의 수를 더한 후, operation의 수로 나눈다. (답이 맞다면 항상 나누어 떨어져야 한다)</li>
</ol></li>
<li>Application:

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-41-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\times n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-41">n\times n</script> (<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-42-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-42">n</script>은 편의를 위해 짝수) 크기의 격자를 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-43-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-43">x</script>개의 색깔로 칠하는 경우의 수는? 단 회전해서 같은 경우는 같은 것으로 친다.

<ul>
<li>아무것도 하지 않을 때: 모든 격자가 변하지 않는다. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-44-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mo>∗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{n*n}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-44">x^{n*n}</script></li>
<li>90도 회전, 270도: 4개씩 칸을 그룹지어, 각 그룹은 같은 색이어야 한다. 따라서 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-45-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mo>∗</mo><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>4</mn></mrow></msup></mrow><annotation encoding="application/x-tex">x^{n*n/4}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-45">x^{n*n/4}</script></li>
<li>180도 회전: 2개씩 칸을 그룹지어, 각 그룹은 같은 색이어야 한다. 따라서 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-46-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mo>∗</mo><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">x^{n*n/2}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-46">x^{n*n/2}</script>개의 경우의 수</li>
</ul></li>
<li>최종 답은 이들의 평균!</li>
<li>만약 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-47-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-47">n</script>이 홀수라면 어떨까?</li>
</ul></li>
</ul>

<h3 id="toc_5"><a href="http://en.wikipedia.org/wiki/Kirchoff%27s_theorem">키르히호프 정리</a></h3>

<ul>
<li>그래프의 생성 수형도(흔히 말하는 스패닝 트리)의 경우의 수를 구하는 정리로 대수적 그래프 이론에서 공부하게 된다.</li>
<li>무향 그래프의 <a href="http://en.wikipedia.org/wiki/Laplacian_matrix">Laplacian matrix</a> <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-48-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-48">L</script>를 만든다. 간단히 설명하면 (정점의 차수 대각 행렬) - (인접행렬)이다. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-49-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-49">L</script>에서 행과 열을 하나씩 제거하고 이것을 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-50-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L^*</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-50">L^*</script>라 하자. 어느 행/열이든 관계 없다. 그래프의 생성 수형도의 개수는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-51-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo movablelimits="true" form="prefix">det</mo><mo stretchy="false">(</mo><msup><mi>L</mi><mrow class="MJX-TeXAtom-ORD"><mo>∗</mo></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\det (L^{*})</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-51">\det (L^{*})</script>이다.</li>
<li>예제: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-52-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">K</mi></mrow><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">\rm{K}_4</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-52">\rm{K}_4</script>의 Laplacian matrix는
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-53-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>[</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>3</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>3</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>3</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>3</mn></mtd></mtr></mtable><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
3 &amp; -1 &amp; -1 &amp; -1 \\
-1 &amp; 3 &amp; -1 &amp; -1 \\
-1 &amp; -1 &amp; 3 &amp; -1 \\
-1 &amp; -1 &amp; -1 &amp; 3 \\
\end{bmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-53">
\begin{bmatrix}
3 & -1 & -1 & -1 \\
-1 & 3 & -1 & -1 \\
-1 & -1 & 3 & -1 \\
-1 & -1 & -1 & 3 \\
\end{bmatrix}
</script>
이다. 여기서 첫번째 행과 첫번째 열을 제거하면 
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-54-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>[</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>3</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>3</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>3</mn></mtd></mtr></mtable><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
3 &amp; -1 &amp; -1 \\
-1 &amp; 3 &amp; -1 \\
-1 &amp; -1 &amp; 3 \\
\end{bmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-54">
\begin{bmatrix}
3 & -1 & -1 \\
-1 & 3 & -1 \\
-1 & -1 & 3 \\
\end{bmatrix}
</script>
이고 가우스 조단 방법을 쓰면 
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-55-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>[</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>1</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>1</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>0</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>4</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>0</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>0</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>0</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>4</mn></mtd></mtr></mtable><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
1 &amp; 1 &amp; 1 \\
0 &amp; 4 &amp; 0 \\
0 &amp; 0 &amp; 4 \\
\end{bmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-55">
\begin{bmatrix}
1 & 1 & 1 \\
0 & 4 & 0 \\
0 & 0 & 4 \\
\end{bmatrix}
</script>
이 되어서 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-56-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>4</mn><mo>×</mo><mn>4</mn><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">1 \times 4 \times 4 = 16</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-56">1 \times 4 \times 4 = 16</script>으로 우리가 알고 있던 Cayley 정리에 의한 답인 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-57-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>4</mn><mrow class="MJX-TeXAtom-ORD"><mn>4</mn><mo>−</mo><mn>2</mn></mrow></msup><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">4^{4-2} = 16</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-57">4^{4-2} = 16</script>과 같다.</li>
</ul>

<h3 id="toc_6"><a href="http://en.wikipedia.org/wiki/Generating_function#Ordinary_generating_functions">생성함수</a></h3>

<ul>
<li>제대로 이 토픽을 다룰 필요는 없지만 경우의 수 문제를 다룰 때 쓰이는 경우가 있다.</li>
<li>1원짜리 동전 5원짜리 동전 8원짜리 동전을 이용해서 몇억원을 만드는 경우의 수를 구한다고 하자. 

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-58-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mo>⋯</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>x</mi><mn>5</mn></msup><mo>+</mo><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>10</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>x</mi><mn>8</mn></msup><mo>+</mo><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>16</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + x + x^2 + \cdots) (1 + x^5 + x^{10} + \cdots) (1 + x^8 + x^{16} + \cdots)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-58">(1 + x + x^2 + \cdots) (1 + x^5 + x^{10} + \cdots) (1 + x^8 + x^{16} + \cdots)</script>를 전개하면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-59-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mo>몇</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>억</mo></mrow></mrow></msup></mrow><annotation encoding="application/x-tex">x^{몇억}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-59">x^{몇억}</script>의 계수가 답이 된다. </li>
<li>생성함수에서 해당 식은 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-60-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>x</mi><mn>5</mn></msup><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>x</mi><mn>8</mn></msup><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{(1-x)(1-x^5)(1-x^8)}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-60"> \frac{1}{(1-x)(1-x^5)(1-x^8)} </script>으로 표현할 수 있다.</li>
<li>계산을 위해 다음을 생각해보자. 1,5,8의 최소공배수인 40을 써서 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-61-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>40</mn></mrow></msup><msup><mo stretchy="false">)</mo><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">(1-x^{40})^3</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-61">(1-x^{40})^3</script>을 곱하면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-62-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>39</mn></mrow></msup><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>x</mi><mn>5</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>35</mn></mrow></msup><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>x</mi><mn>8</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>32</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1+x+\cdots+x^{39})(1+x^5+\cdots+x^{35})(1+x^8+\cdots+x^{32})</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-62">(1+x+\cdots+x^{39})(1+x^5+\cdots+x^{35})(1+x^8+\cdots+x^{32})</script>이다. 해당 식의 분자와 분모에 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-63-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>40</mn></mrow></msup><msup><mo stretchy="false">)</mo><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">(1-x^{40})^3</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-63">(1-x^{40})^3</script>을 곱하는 것을 생각해주면 된다. 분자는 106차식이다. 107개 항으로 쪼개고 분모의 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-64-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>40</mn></mrow></msup><msup><mo stretchy="false">)</mo><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">(1-x^{40})^3</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-64">(1-x^{40})^3</script>으로부터 얻어지는 계수를 곱해주고 더하면 원하는 답을 얻는다.

<ul>
<li>분모로부터 얻어지는 계수는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-65-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mrow><mrow class="MJX-TeXAtom-OPEN"><mo maxsize="1.2em" minsize="1.2em">(</mo></mrow><mfrac linethickness="0"><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mn>2</mn></mfrac><mrow class="MJX-TeXAtom-CLOSE"><mo maxsize="1.2em" minsize="1.2em">)</mo></mrow></mrow></mrow><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>40</mn><mi>n</mi></mrow></msup></mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>40</mn></mrow></msup><msup><mo stretchy="false">)</mo><mn>3</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\sum{ {n+2 \choose 2} x^{40 n} } = \frac{1}{(1-x^{40})^3}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-65">\sum{ {n+2 \choose 2} x^{40 n} } = \frac{1}{(1-x^{40})^3} </script>에서 얻는다. 이렇게 되면 항상 40의 배수이므로 유효하게 고려하는 항의 개수는 약 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-66-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>40</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{40}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-66">\frac{1}{40}</script>으로 줄어든다.</li>
</ul></li>
<li>이 예제처럼 터무니 없이 큰 범위에 대해 답을 계산해야할 때는 수식만 잘 다룰 줄 알면 쉽다. SRM 600.5의 1000점 문제는 이러한 방식으로 풀린다.</li>
</ul></li>
<li>어떤 수열의 점화식을 알 때 수열의 합을 구할 때도 쓸 수 있다. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-67-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><msub><mi>a</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup></mrow></mrow><annotation encoding="application/x-tex">\sum{a_n x^n}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-67">\sum{a_n x^n}</script> 꼴로 우리가 원하는 답이 표현되는 경우에 적용할 수 있다.

<ul>
<li><a href="http://en.wikipedia.org/wiki/Fibonacci_number#Power_series">피보나치 수열의 power series</a>가 유명한 예이다. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-68-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:=</mo><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><msub><mi>F</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup></mrow><mo>=</mo><mfrac><mi>x</mi><mrow><mn>1</mn><mo>−</mo><mi>x</mi><mo>−</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">s(x) := \sum{F_n x^n} = \frac{x}{1-x-x^2}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-68">s(x) := \sum{F_n x^n} = \frac{x}{1-x-x^2}</script>임을 s(x) 정의와 점화식에서 얻을 수 있다. x가 수렴하는 범위(황금비의 역수보다 절대값이 작은 경우)에 있기만 하면 된다.</li>
</ul></li>
<li>읽어볼만한 pdf <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2010/lecture-notes/MIT6_042JS10_lec31.pdf">링크</a></li>
</ul>

<h2 id="toc_7">게임이론</h2>

<h3 id="toc_8"><a href="http://en.wikipedia.org/wiki/Sprague%E2%80%93Grundy_theorem">스프라그-그룬디 정리</a></h3>

<ul>
<li><a href="http://www.gabrielnivasch.org/fun/combinatorial-games/sprague-grundy">튜토리얼 링크</a>, <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=algorithmGames">탑코더 튜토리얼</a>, <a href="http://blog.plover.com/math/sprague-grundy.html">또다른 튜토리얼</a></li>
<li><a href="http://en.wikipedia.org/wiki/Nim">Nim 게임</a>

<ul>
<li>규칙

<ul>
<li>조약돌 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-69-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-69">k</script> 무더기가 있다고 하자. 각 무더기에 포함된 조약돌의 개수는 다를 수 있다.</li>
<li>각 플레이어는 무더기를 하나 선택해서 그 무더기에서 1개 이상의 조약돌을 가져온다. (무더기에 남은 조약돌을 전부 가져와도 된다.)</li>
<li>마지막 조약돌을 가져가는 플레이어가 승리한다.</li>
</ul></li>
<li>Nim 게임의 해법

<ul>
<li>각 무더기의 조약돌 수를 전부 XOR한다. 0이면 패배! 0 이상이면 승리!</li>
</ul></li>
</ul></li>
<li>일반화하기:

<ul>
<li>모든 <a href="http://en.wikipedia.org/wiki/Impartial_game">impartial</a>(어느 플레이어든지 놓을 수 있는 수가 같다), <a href="http://en.wikipedia.org/wiki/Normal_play_convention">normal play</a>(마지막에 수를 두는 사람이 이긴다) 게임은 비슷한 해법으로 풀 수 있다.

<ul>
<li>다음과 같은 규칙:

<ul>
<li>게임은 한 개 이상의 서브게임으로 구성된다.</li>
<li>각 서브게임은 상태들의 DAG로 구성된다. </li>
<li>각 플레이어는 하나의 서브게임을 골라 해당 서브게임의 상태를 한 번 움직인다.</li>
<li>더 이상 움직일 수 없는 사람이 진다.</li>
</ul></li>
</ul></li>
<li>어떻게 풀까?

<ul>
<li>게임의 각 상태에 대해 Grundy 수를 계산한다. </li>
<li>우선 하나의 서브게임만 보자.

<ul>
<li>지는 상태(마지막 상태)의 Grundy 수는 0이다.</li>
<li>그 외의 상태에서는 이 상태에서 나가는 상태들의 Grundy 수를 모은 뒤, 그 중에 포함되지 않은 가장 작은 0 이상의 정수(minimum excluded number)가 Grundy 수가 된다.</li>
</ul></li>
<li>여러 개의 서브게임이 있다면 각 서브게임의 상태를 XOR한다.</li>
</ul></li>
<li>Nim에서는: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-70-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-70">n</script>개의 조약돌이 남아있다면 Grundy 수는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-71-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-71">n</script></li>
</ul></li>
<li>Application: fill in!</li>
</ul>

<h2 id="toc_9">확률론</h2>

<h3 id="toc_10">기대값의 선형성</h3>

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-72-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><munder><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><mi>i</mi></mrow></munder><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><mi>E</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(\sum_{i}A_i) = \sum_i E(A_i)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-72">E(\sum_{i}A_i) = \sum_i E(A_i)</script></li>
<li>당연한 얘기같지만 가끔 예상치 못한 간단한 답을 준다! 합을 어떻게 나누느냐에 따라 중요.</li>
<li>Application

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-73-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-73">N+1</script>층짜리 건물의 1층에 엘리베이터가 섰는데, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-74-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-74">M</script>명이 탔다. 각 사람이 가는 층은 랜덤하게 결정된다. 엘리베이터가 서는 횟수의 기대값은?

<ul>
<li>각 층별로 설 때 1이 되는 indicator function의 기대치를 구해서 더한다.</li>
</ul></li>
<li><a href="http://petr-mitrichev.blogspot.kr/2013/11/this-week-in-competitive-programming.html">또 다른 예제</a>: 평면상에 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-75-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-75">N</script>개의 점이 있다. 각 점마다 해당 점이 존재하거나 지워질 확률이 주어진다. Convex hull 넓이의 기대값은?

<ul>
<li>각 간선별로 외적값의 기대치를 더한다.</li>
</ul></li>
</ul></li>
</ul>

<h2 id="toc_11">정수론</h2>

<h3 id="toc_12">모듈라 연산</h3>

<ul>
<li>N으로 나눈 결과값을 구할 때, 연산 중간 결과도 N으로 나눠도 된다. 

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-76-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi><mo>+</mo><mi>b</mi><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">(a + b) \mathrm{mod}N = (a \mathrm{mod}N + b\mathrm{mod}N) \mathrm{mod}N</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-76">(a + b) \mathrm{mod}N = (a \mathrm{mod}N + b\mathrm{mod}N) \mathrm{mod}N</script></li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-77-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi><mo>−</mo><mi>b</mi><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">(a - b) \mathrm{mod}N = (a \mathrm{mod}N - b\mathrm{mod}N + N) \mathrm{mod}N</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-77">(a - b) \mathrm{mod}N = (a \mathrm{mod}N - b\mathrm{mod}N + N) \mathrm{mod}N</script></li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-78-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>∗</mo><mi>b</mi><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi><mo>∗</mo><mi>b</mi><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">(a * b) \mathrm{mod}N = (a \mathrm{mod}N * b\mathrm{mod}N) \mathrm{mod}N</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-78">(a * b) \mathrm{mod}N = (a \mathrm{mod}N * b\mathrm{mod}N) \mathrm{mod}N</script></li>
</ul></li>
<li>단 나눗셈에는 성립하지 않는다. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-79-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-79">a</script>로 나누기 위해서는, 곱셈의 역원을 대신 곱해줘야 한다. <a href="http://en.wikipedia.org/wiki/Modular_multiplicative_inverse">모듈라 곱셈의 역원</a>은 두 가지 방법으로 구할 수 있다.

<ul>
<li>한 가지 방법은 오일러 정리를 이용하는 것이다.

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-80-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi>ϕ</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></msup><mo>≡</mo><mn>1</mn><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^{\phi(N)} \equiv 1 (\mathrm{mod}N)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-80">a^{\phi(N)} \equiv 1 (\mathrm{mod}N)</script></li>
<li>이 때 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-81-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>h</mi><mi>i</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">phi(N)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-81">phi(N)</script>은 오일러 피 함수. 아래를 참조하라. 단 이거 계산하는건 배보다 배꼽이 더 클 수도.</li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-82-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-82">N</script>이 소수라면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-83-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\phi(N)=N-1</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-83">\phi(N)=N-1</script>이니 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-84-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mi>N</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{N-2}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-84">a^{N-2}</script>을 계산하여 역원을 얻을 수 있다.</li>
<li>이것을 거듭제곱 빨리 구하기로 구하면 된다.</li>
</ul></li>
<li>두번째 방법(아마 더 효율적)은 확장 유클리드 알고리즘을 쓰는것이다. 아래를 참조하라.</li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-85-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1..</mn><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1..N]</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-85">[1..N]</script>구간에 대해서 각각의 역원을 미리 계산해 둬야 한다면, DP를 이용해 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-86-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-86">O(N)</script>에 구하는 방법도 있다. <a href="http://codeforces.ru/blog/entry/13908#comment-188854">codeforces 링크</a>를 참조. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-87-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-87">p</script>에 대해서 구할 경우, 점화식은 다음과 같다.

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-88-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mo stretchy="false">[</mo><mi>p</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>∗</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mi>p</mi><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>i</mi><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">inv(i)=(p-[p/i])*inv(p \mathrm{mod}i) \mathrm{mod} p</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-88">inv(i)=(p-[p/i])*inv(p \mathrm{mod}i) \mathrm{mod} p</script></li>
</ul></li>
</ul></li>
</ul>

<h3 id="toc_13">확장 유클리드 알고리즘</h3>

<ul>
<li>목적: 상수 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-89-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-89">a</script>, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-90-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-90">b</script>에 대해 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-91-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">g</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax + by = \mathrm{gcd}(a, b)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-91">ax + by = \mathrm{gcd}(a, b)</script>를 만족하는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-92-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-92">x</script>, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-93-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-93">y</script>를 찾아준다. </li>
<li>Naive derivation:

<ul>
<li>유클리드 gcd 알고리즘에서, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-94-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd()</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-94">gcd()</script>의 입력이 되는 숫자들은 항상 최초 숫자들의 선형 결합으로 표현할 수 있다.</li>
<li>따라서 각 숫자 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-95-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-95">a</script>와 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-96-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-96">b</script>를 넘길 때, 이들을 최초 숫자들의 선형 결합으로 표현한 방법 또한 넘겨주면 간단하게 풀 수 있다.</li>
<li>물론 이대로 구현하면 아주 귀찮다. 대신에 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-97-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-97">gcd(a, b)</script> 함수가 최대공약수와 함께 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-98-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">ax+by=g</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-98">ax+by=g</script> 의 해 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-99-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-99">x</script>, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-100-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-100">y</script>를 반환하도록 하면 쉽게 풀 수 있다.</li>
</ul></li>
</ul>

<p>C++ 구현</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">Solution</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">gcd</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
<span class="n">Solution</span> <span class="nf">extendedEuclid</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">Solution</span><span class="p">{</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span> 
  <span class="n">Solution</span> <span class="n">s</span> <span class="o">=</span> <span class="n">extendedEuclid</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>                                                                                                            
  <span class="c1">// now, we have</span>
  <span class="c1">// s.gcd = s.x * b + s.y * r</span>
  <span class="c1">//       = s.x * b + s.y * (a - q * b)</span>
  <span class="c1">//       = s.y * a + (s.x - q * s.y) * b</span>
  <span class="k">return</span> <span class="n">Solution</span><span class="p">{</span><span class="n">s</span><span class="p">.</span><span class="n">gcd</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">q</span> <span class="o">*</span> <span class="n">s</span><span class="p">.</span><span class="n">y</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>

<ul>
<li>Application:

<ul>
<li>위에서 얘기했듯이, 모듈라 연산에서 곱셈의 역원 구하기. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-101-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">\mathrm{mod } N</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-101">\mathrm{mod } N</script>인 모듈로 연산을 할 때, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-102-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-102">a</script>와 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-103-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-103">N</script>이 서로소라 하자. (<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-104-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-104">N</script>이 소수면 항상 참) 따라서 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-105-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-105">a</script>와 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-106-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-106">N</script>의 egcd 결과는 항상 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-107-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>N</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + Ny = 1</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-107">ax + Ny = 1</script>이 된다. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-108-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-108">N</script>로 나눠보면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-109-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>=</mo><mn>1</mn><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax = 1 (\mathrm{mod }N)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-109">ax = 1 (\mathrm{mod }N)</script>. 따라서 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-110-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-110">x</script>는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-111-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-111">a</script>의 곱셈 역원이다. (단, 결과값이 음수라면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-112-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-112">N</script>을 더해줘야 함)</li>
</ul></li>
</ul>

<h3 id="toc_14">중국인 나머지 정리</h3>

<h3 id="toc_15"><a href="http://en.wikipedia.org/wiki/Lucas%27_theorem">뤼카의 정리</a></h3>

<ul>
<li>음이 아닌 정수 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-113-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-113">m</script>, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-114-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-114">n</script>과 임의의 소수 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-115-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-115">p</script>에 대해 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-116-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow class="MJX-TeXAtom-ORD"><mrow><mrow class="MJX-TeXAtom-OPEN"><mo maxsize="1.2em" minsize="1.2em">(</mo></mrow><mfrac linethickness="0"><mi>m</mi><mi>n</mi></mfrac><mrow class="MJX-TeXAtom-CLOSE"><mo maxsize="1.2em" minsize="1.2em">)</mo></mrow></mrow></mrow><mspace width="0.444em"></mspace><mo stretchy="false">(</mo><mi>mod</mi><mspace width="0.333em"></mspace><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{m \choose n}\pmod p</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-116">{m \choose n}\pmod p</script>를 계산하는 정리이다.</li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-117-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-117">m</script>과 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-118-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-118">n</script>을 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-119-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-119">p</script>진법으로 전개하여 그 p진 숫자를 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-120-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-120">m_i</script>와 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-121-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-121">n_i</script>라고 하자. 자리수가 다르면 0을 채워넣어 맞춰준다. 그러면 
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-122-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow class="MJX-TeXAtom-ORD"><mrow><mrow class="MJX-TeXAtom-OPEN"><mo maxsize="1.2em" minsize="1.2em">(</mo></mrow><mfrac linethickness="0"><mi>m</mi><mi>n</mi></mfrac><mrow class="MJX-TeXAtom-CLOSE"><mo maxsize="1.2em" minsize="1.2em">)</mo></mrow></mrow></mrow><mo>≡</mo><mo>∏</mo><mrow class="MJX-TeXAtom-ORD"><mrow><mrow class="MJX-TeXAtom-OPEN"><mo maxsize="1.2em" minsize="1.2em">(</mo></mrow><mfrac linethickness="0"><msub><mi>m</mi><mi>i</mi></msub><msub><mi>n</mi><mi>i</mi></msub></mfrac><mrow class="MJX-TeXAtom-CLOSE"><mo maxsize="1.2em" minsize="1.2em">)</mo></mrow></mrow></mrow><mspace width="0.444em"></mspace><mo stretchy="false">(</mo><mi>mod</mi><mspace width="0.333em"></mspace><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{m \choose n}\equiv\prod{m_i \choose n_i}\pmod p</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-122">{m \choose n}\equiv\prod{m_i \choose n_i}\pmod p</script>이다. </li>
<li>이 때 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-123-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i &lt; n_i</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-123">m_i < n_i</script>이면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-124-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow class="MJX-TeXAtom-ORD"><mrow><mrow class="MJX-TeXAtom-OPEN"><mo maxsize="1.2em" minsize="1.2em">(</mo></mrow><mfrac linethickness="0"><msub><mi>m</mi><mi>i</mi></msub><msub><mi>n</mi><mi>i</mi></msub></mfrac><mrow class="MJX-TeXAtom-CLOSE"><mo maxsize="1.2em" minsize="1.2em">)</mo></mrow></mrow></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">{m_i \choose n_i} = 0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-124">{m_i \choose n_i} = 0</script>으로 취급한다.</li>
</ul>

<h3 id="toc_16"><a href="http://en.wikipedia.org/wiki/Euler%27s_totient_function">오일러 피 함수</a>, <a href="http://en.wikipedia.org/wiki/Divisor_function">약수의 합(시그마) 함수, 약수의 개수 함수</a>, <a href="http://en.wikipedia.org/wiki/Moebius_function">뫼비우스 함수</a></h3>

<ul>
<li>이 함수들은 서로소인 것들에 대해 multiplicative 함수들이기 때문에 n 이하의 모든 값을 계산해야할 경우 에라토스테네스의 체를 이용하면 O(n log n)에 된다.</li>
<li>오일러 피 함수는 자신보다 작은 서로소인 정수의 개수를 나타내는 함수이다.

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-125-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><munder><mo>∏</mo><mrow class="MJX-TeXAtom-ORD"><mi>p</mi><mo>∣</mo><mi>n</mi></mrow></munder><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>p</mi></mfrac></mrow><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\varphi(n) =n \prod_{p\mid n} \left(1-\frac{1}{p}\right)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-125">\varphi(n) =n \prod_{p\mid n} \left(1-\frac{1}{p}\right)</script>이고, 소인수 분해한 경우를 생각하면 계산하기 쉽다.</li>
</ul></li>
<li>어떤 정수가 있을 때, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-126-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-126">p_i</script>를 소인수라고 하고 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-127-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-127">a_i</script>를 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-128-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-128">p_i</script> 소인수의 거듭제곱 횟수라고 하자. 약수의 합(x=1), 약수의 개수(x=0) 함수는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-129-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msubsup><mi>p</mi><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>x</mi></mrow></msubsup><mo>+</mo><mo>⋯</mo><mo>+</mo><msubsup><mi>p</mi><mi>i</mi><mrow class="MJX-TeXAtom-ORD"><mi>x</mi><msub><mi>a</mi><mi>i</mi></msub></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\prod(1+p_i^{x}+\cdots+p_i^{x a_i})</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-129">\prod(1+p_i^{x}+\cdots+p_i^{x a_i})</script>로 계산할 수 있다. </li>
<li>뫼비우스 함수는 
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-130-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mo>∑</mo><mrow class="MJX-TeXAtom-ORD"><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>n</mi></mrow></munder><mi>μ</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo>{</mo><mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false"><mtr><mtd style="padding: 0px;"><mn>1</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mstyle displaystyle="false" scriptlevel="0"><mtext>&nbsp;if&nbsp;</mtext></mstyle><mi>n</mi><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 0.2em 0px 0px;"><mn>0</mn></mtd><mtd style="padding: 0.2em 0px 0px 1em;"><mstyle displaystyle="false" scriptlevel="0"><mtext>&nbsp;if&nbsp;</mtext></mstyle><mi>n</mi><mo>&gt;</mo><mn>1.</mn></mtd></mtr></mtable><mo fence="true" stretchy="true" symmetric="true"></mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{d | n} \mu(d) = \begin{cases}1&amp;\mbox{ if } n=1\\
0&amp;\mbox{ if } n&gt;1.\end{cases}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-130">\sum_{d | n} \mu(d) = \begin{cases}1&\mbox{ if } n=1\\
0&\mbox{ if } n>1.\end{cases}</script>를 사용해 계산할 수 있다.</li>
<li>이 함수들의 관계는 <a href="http://en.wikipedia.org/wiki/Euler%27s_totient_function#Divisor_sum">위키피디아 링크</a>를 참고</li>
</ul>

<h2 id="toc_17">분할 정복을 이용한 빠른 수식 계산</h2>

<h3 id="toc_18">빠른 거듭 제곱 계산</h3>

<ul>
<li>분할 정복: 

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-131-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn><mi>n</mi></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mi>n</mi></msup><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x^{2n} = (x^n) \cdot (x^n)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-131">x^{2n} = (x^n) \cdot (x^n)</script></li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-132-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi>x</mi><mo>⋅</mo><msup><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{(2n+1)} = x \cdot x^{2n}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-132">x^{(2n+1)} = x \cdot x^{2n}</script></li>
</ul></li>
</ul>

<h3 id="toc_19">빠른 등비 수열의 합</h3>

<ul>
<li>분할 정복: 

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-133-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn><mi>n</mi></mrow></msup><mo>+</mo><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">A^{2n} + A^{2n-1} + A^{2n-2} + \cdots + A^{1}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-133">A^{2n} + A^{2n-1} + A^{2n-2} + \cdots + A^{1} </script></li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-134-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mo stretchy="false">(</mo><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn><mi>n</mi></mrow></msup><mo>+</mo><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msup><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">= (A^{2n} + A^{n}) + (A^{2n-1} + A^{n-1}) + \cdots</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-134">= (A^{2n} + A^{n}) + (A^{2n-1} + A^{n-1}) + \cdots</script></li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-135-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>A</mi><mi>n</mi></msup><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msup><mo>+</mo><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">= (1 + A^n)(A^{n} + A^{n-1} + \cdots + A^{1})</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-135">= (1 + A^n)(A^{n} + A^{n-1} + \cdots + A^{1})</script></li>
</ul></li>
</ul>

<h3 id="toc_20">행렬의 합</h3>

<ul>
<li>수열에 대한 테크닉을 바로 쓸 수도 있지만 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-136-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>−</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">I-A</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-136">I-A</script>의 역행렬이 있는 경우에는 

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-137-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><mtr><mtd style="padding: 0px;"><mi>I</mi><mo>+</mo><mi>A</mi><mo>+</mo><msup><mi>A</mi><mn>2</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mi>A</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mtd><mtd style="padding: 0px 0px 0px 0em;"><mi></mi><mo>=</mo><mo stretchy="false">(</mo><mi>I</mi><mo>−</mo><msup><mi>A</mi><mi>n</mi></msup><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>I</mi><mo>−</mo><mi>A</mi><msup><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mo>−</mo><mn>1</mn></mrow></msup></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{align}
I + A + A^2 + \cdots + A^{n-1} &amp; = (I - A^n)(I-A)^{-1}\\
\end{align}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-137">
\begin{align}
I + A + A^2 + \cdots + A^{n-1} & = (I - A^n)(I-A)^{-1}\\
\end{align}
</script></li>
<li>무한히 더해야 할 때, 합이 수렴하는 경우 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-138-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>I</mi><mo>−</mo><mi>A</mi><msup><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(I-A)^{-1}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-138">(I-A)^{-1}</script>이 답이 된다.</li>
</ul></li>
</ul>

<h2 id="toc_21">선형 시스템</h2>

<h3 id="toc_22">가우스 소거법</h3>

<ul>
<li>가우스 소거법은 역행렬 계산, determinant 계산, 일차연립방정식 풀이 등에 쓸 수 있는 방법을 정리한 것이다. 행렬의 rank는 변하지 않는 연산들로 이뤄져 있다. 최종 목적은 <a href="http://en.wikipedia.org/wiki/Row_echelon_form">row echelon form</a> 또는 대각행렬로 만드는 경우가 많다.</li>
<li>사용할 수 있는 연산

<ol>
<li>어떤 값 k를 원하는 행 하나를 택하여 곱한 결과를 다른 행에 더한다. 가장 기본이 되는 연산이고 determinant는 보존된다.

<ul>
<li>예제:
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-139-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>(</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>3</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>4</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>5</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>5</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>2</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix}
3 &amp; 4 &amp; 1 \\
5 &amp; 5 &amp; 2
\end{pmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-139">
\begin{pmatrix}
3 & 4 & 1 \\
5 & 5 & 2
\end{pmatrix}
</script>
에 첫번째 행에 -2를 곱하고 두번째 행에 더하여 
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-140-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>(</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>3</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>4</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>−</mo><mn>3</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix}
3 &amp; 4 &amp; 1 \\
-1 &amp; -3 &amp; 0
\end{pmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-140">
\begin{pmatrix}
3 & 4 & 1 \\
-1 & -3 & 0
\end{pmatrix}
</script>
을 얻는 작업을 해볼 수 있다.</li>
<li>이 예제의 작업을 matrix 곱으로 표현하면 다음과 같다. 행렬 determinant는 multiplicative이므로(<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-141-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo movablelimits="true" form="prefix">det</mo><mrow class="MJX-TeXAtom-ORD"><mi>A</mi><mi>B</mi></mrow><mo>=</mo><mo movablelimits="true" form="prefix">det</mo><mrow class="MJX-TeXAtom-ORD"><mi>A</mi></mrow><mo>⋅</mo><mo movablelimits="true" form="prefix">det</mo><mrow class="MJX-TeXAtom-ORD"><mi>B</mi></mrow></mrow><annotation encoding="application/x-tex">\det{AB} = \det{A} \cdot \det{B}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-141">\det{AB} = \det{A} \cdot \det{B}</script>) 다음의 등식에서 determinant가 보존되는 것을 확인할 수 있다.

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-142-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>(</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>1</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>0</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mo>−</mo><mn>2</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow><mrow><mo>(</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>3</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>4</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>5</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>5</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>2</mn></mtd></mtr></mtable><mo>)</mo></mrow><mo>=</mo><mrow><mo>(</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>3</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>4</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>−</mo><mn>3</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix}
1 &amp; 0 \\
-2 &amp; 1
\end{pmatrix}
\begin{pmatrix}
3 &amp; 4 &amp; 1 \\
5 &amp; 5 &amp; 2
\end{pmatrix}
=
\begin{pmatrix}
3 &amp; 4 &amp; 1 \\
-1 &amp; -3 &amp; 0
\end{pmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-142">
\begin{pmatrix}
1 & 0 \\
-2 & 1
\end{pmatrix}
\begin{pmatrix}
3 & 4 & 1 \\
5 & 5 & 2
\end{pmatrix}
=
\begin{pmatrix}
3 & 4 & 1 \\
-1 & -3 & 0
\end{pmatrix}
</script></li>
</ul></li>
</ul></li>
<li>어떤 값 k를 원하는 행 하나를 택하여 곱해준다. 이 연산의 결과로 행렬의 determinant는 k배가 된다.

<ul>
<li>첫번째 행을 k배 한다고 하면 다음과 같은 행렬을 곱해준 것으로 생각할 수 있다.
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-143-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>(</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mi>k</mi></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>0</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mo>⋯</mo></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>0</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>0</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>⋯</mo></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>0</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mo>⋮</mo></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>⋮</mo></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>⋱</mo></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>⋮</mo></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>0</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>0</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>⋯</mo></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix} k &amp; 0 &amp; \cdots &amp; 0\\ 0 &amp; 1 &amp; \cdots &amp; 0\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; \cdots &amp; 1 \end{pmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-143"> \begin{pmatrix} k & 0 & \cdots & 0\\ 0 & 1 & \cdots & 0\\ \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & \cdots & 1 \end{pmatrix}</script></li>
</ul></li>
<li>원하는 행 두 개를 바꿔준다. 이 연산의 결과로 행렬의 determinant는 -1배가 된다.

<ul>
<li>첫째 행과 둘째 행을 교체한다고 하면 다음과 같은 행렬을 곱해준 것으로 생각할 수 있다.
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-144-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>(</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>0</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>1</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mo>⋯</mo></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>0</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>0</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>⋯</mo></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>0</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mo>⋮</mo></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>⋮</mo></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>⋱</mo></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>⋮</mo></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>0</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>0</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mo>⋯</mo></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix} 0 &amp; 1 &amp; \cdots &amp; 0\\ 1 &amp; 0 &amp; \cdots &amp; 0\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; \cdots &amp; 1 \end{pmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-144"> \begin{pmatrix} 0 & 1 & \cdots & 0\\ 1 & 0 & \cdots & 0\\ \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & \cdots & 1 \end{pmatrix}</script></li>
</ul></li>
</ol></li>
<li>사용하는 방법

<ul>
<li>역행렬: 대상 행렬에 해주는 작업을 단위행렬에 똑같이 해주되 대상 행렬을 단위행렬로 만들면 같은 작업을 적용해줬던 단위행렬은 역행렬로 바뀌어 있다.

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-145-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>(</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>2</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mn>3</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>2</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix}
2 &amp; 3 \\
1 &amp; 2
\end{pmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-145">\begin{pmatrix}
2 & 3 \\
1 & 2
\end{pmatrix}</script> 를 단위행렬로 만드는 연산의 예제는 다음과 같다.

<ul>
<li>2번 행을 1번 행에서 뺀다. 1번 행은 1 1이 된다.</li>
<li>1번 행을 2번 행에서 뺀다. 2번 행은 0 1이 된다.</li>
<li>2번 행을 1번 행에서 뺀다. 1번 행은 1 0이 된다.</li>
</ul></li>
<li>해당 작업을 단위행렬에 똑같이 순서대로 해주면
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-146-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>(</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><mn>2</mn></mtd><mtd style="padding: 0px 0px 0px 1em;"><mo>−</mo><mn>3</mn></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><mo>−</mo><mn>1</mn></mtd><mtd style="padding: 4pt 0px 0px 1em;"><mn>2</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix}
2 &amp; -3 \\
-1 &amp; 2
\end{pmatrix}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-146">\begin{pmatrix}
2 & -3 \\
-1 & 2
\end{pmatrix}</script>이 된다. </li>
</ul></li>
<li>determinant를 구할 때도 쓸 수 있다. 키르히호프 정리의 예제처럼 삼각형 모양이면 대각선을 곱해주는 것으로 계산할 수 있다. 그러한 구하기 쉬운 모양으로 변환해주면서 determinant가 어떻게 변해왔는지 기억하면 원래 행렬의 determinant를 계산할 수 있다.</li>
<li>일차연립방정식 풀이

<ul>
<li>연립방정식을 행렬로 표현한다. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-147-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-147">m</script>개의 연립 방정식에 변수가 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-148-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-148">n</script>개라고 하자. 계수를 의미하는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-149-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-149">m \times n</script>짜리 행렬 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-150-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-150">A</script>와 변수 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-151-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-151">n</script>개를 의미하는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-152-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \times 1</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-152">n \times 1</script>짜리 열 벡터 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-153-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-153">x</script>와 남은 상수항을 의미하는 열 벡터 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-154-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-154">b</script>를 생각하면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-155-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">Ax = b</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-155">Ax = b</script>로 연립일차방정식을 표현할 수 있다.</li>
<li>양 변에 똑같은 작업을 해주면서 좌측의 행렬을 단위행렬처럼 만들면 x를 알 수 있다.</li>
</ul></li>
<li>원하는 모양을 만들기 위한 전략으로는 다음의 것이 많이 쓰인다.

<ul>
<li>0행 0열의 원소를 1로 만들어주고 i행 0열의 원소를 0으로 만들어준다.</li>
<li>1행 1열의 원소를 1로 만들어주고 i행 1열의 원소를 0으로 만들어준다.</li>
<li>행렬의 끝에 도달할 때까지 대각선을 1로 만들고 나머지를 0으로 만드는 작업을 계속 반복하여 단위행렬을 얻는다.</li>
<li>항상 대각선을 1로 만들 수 있는 것은 아니다. 그러한 경우 1로 만들 위치는 오른쪽으로 한 칸 옮겨서 진행한다. 그렇게 작업한 경우 row echolon form이 된다.</li>
</ul></li>
</ul></li>
</ul>

<h3 id="toc_23">심플렉스법</h3>

<ul>
<li>진짜로 이거 필요할까? -_-</li>
</ul>

<h3 id="toc_24">리니어 시스템과 플로우</h3>

<h2 id="toc_25">기초 수치 해석</h2>

<h3 id="toc_26">Newton method</h3>

<ul>
<li>가장 기초적인 근 찾기(root-finding) 알고리즘. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-156-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-156">f(x)</script>와 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-157-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f'(x)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-157">f'(x)</script>의 구현이 주어질 때, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-158-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x)=0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-158">f(x)=0</script>인 위치를 찾는다. </li>
<li>처음에 답이 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-159-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-159">x_0</script>이라고 찍어보자. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-160-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_0)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-160">f(x_0)</script>을 계산해보니 0이 아니었다. 그러면 어떻게 할까?</li>
<li>좋은 방법은 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-161-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-161">f(x)</script>를 선형함수로 근사하고, 이 경우 해가 되는 위치가 어디일지를 찾는 것이다. 다음 그림을 참조하자. (<a href="http://www.ms.uky.edu/%7Ecarl/ma123/kob98/kob98htm/chap15e1.html">출처</a></li>
</ul>

<p><img src="http://www.ms.uky.edu/%7Ecarl/ma123/kob98/kob98htm/images/chap15e28.gif" alt=""> </p>

<p>C++ 구현</p>
<div class="highlight"><pre><span class="c1">// f(x)와 f'(x), 초기값이 주어졌을 때 해를 찾는다.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Function1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Function2</span><span class="o">&gt;</span>
<span class="kt">double</span> <span class="n">newton</span><span class="p">(</span><span class="n">Function1</span> <span class="n">f</span><span class="p">,</span> <span class="n">Function2</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">double</span> <span class="n">init</span><span class="p">,</span> <span class="kt">double</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">iterations</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">fx</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">fx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">)</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">fpx</span> <span class="o">=</span> <span class="n">fp</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="n">fx</span> <span class="o">/</span> <span class="n">fpx</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// did not converge!</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h3 id="toc_27"><a href="http://en.wikipedia.org/wiki/Adaptive_Simpson's_method">Adaptive Simpson 수치 적분</a></h3>

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-162-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-162">f(x)</script> 함수의 구현이 주어질 때, 해당 함수를 여러번 호출해서 해당 함수의 부정적분 없이도 정적분을 계산하는 기법들.

<ul>
<li><a href="http://en.wikipedia.org/wiki/Simpson's_rule">Simpson법</a>은 해당 함수를 2차함수로 근사해서 적분한다. 따라서 해당 함수가 2차 이하라면 항상 정확한 답이 나온다.</li>
<li>Adaptive Simpson 적분 알고리즘은 해당 함수가 2차 함수에서 얼마나 벗어나는지 확인하고, 많이 벗어난다면 분할 정복한다. 자세한 백그라운드는 나도 모르니 싣지 않는다. 구현은 다음과 같다.</li>
</ul></li>
</ul>

<p>C++ 구현</p>
<div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Function</span><span class="o">&gt;</span>
<span class="kt">double</span> <span class="n">simpson</span><span class="p">(</span><span class="n">Function</span> <span class="n">f</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">h3</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="mf">6.0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">h3</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// sum은 처음에 simpson(f, a, b)로 초기화한다.</span>
<span class="c1">// 오차가 eps 이상으로 추정되는 경우 분할정복한다.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Function</span><span class="o">&gt;</span>
<span class="kt">double</span> <span class="n">adaptiveSimpson</span><span class="p">(</span><span class="n">Function</span> <span class="n">f</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">sum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">left</span> <span class="o">=</span> <span class="n">simpson</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">right</span> <span class="o">=</span> <span class="n">simpson</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">-</span> <span class="n">sum</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">15</span> <span class="o">*</span> <span class="n">eps</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">-</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">-</span> <span class="n">sum</span><span class="p">)</span> <span class="o">/</span> <span class="mi">15</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">adaptiveSimpson</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">eps</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">adaptiveSimpson</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">eps</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h2 id="toc_28">긴 정수 곱셈</h2>

<h3 id="toc_29">카라츠바 알고리즘</h3>

<ul>
<li>카라츠바 알고리즘은 긴 정수 둘을 곱하는 분할 정복 알고리즘이다. <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-163-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-163">B</script>진수 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-164-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-164">n</script>자리 긴 정수 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-165-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-165">a</script>, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-166-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-166">b</script>를 곱한다고 하자. (<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-167-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-167">n</script>은 2의 자승으로 가정한다.)</li>
<li>이 때 두 숫자를 모두 절반(<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-168-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-168">n/2</script> 자리씩)으로 다음과 같이 자르자.

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-169-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow></msub><mo>×</mo><msup><mi>B</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a = a_{1} \times B^{n/2} + a_{0}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-169">a = a_{1} \times B^{n/2} + a_{0}</script></li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-170-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><msub><mi>b</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow></msub><mo>×</mo><msup><mi>B</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>b</mi><mrow class="MJX-TeXAtom-ORD"><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">b = b_{1} \times B^{n/2} + b_{0}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-170">b = b_{1} \times B^{n/2} + b_{0}</script></li>
</ul></li>
<li>이 때 다음과 같이 두자.

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-171-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mn>0</mn></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>×</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">z_0 = a_0 \times b_0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-171">z_0 = a_0 \times b_0</script></li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-172-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mn>2</mn></msub><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo>×</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">z_2 = a_1 \times b_1</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-172">z_2 = a_1 \times b_1</script></li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-173-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>0</mn></msub><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>−</mo><msub><mi>z</mi><mn>0</mn></msub><mo>−</mo><msub><mi>z</mi><mn>1</mn></msub><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>×</mo><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mo>×</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">z_1 = (a_0 + a_1) \times (b_0 + b_1) - z_0 - z_1 = a_0 \times b_1 + a_1 \times b_0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-173">z_1 = (a_0 + a_1) \times (b_0 + b_1) - z_0 - z_1 = a_0 \times b_1 + a_1 \times b_0</script></li>
</ul></li>
<li>그러면 

<ul>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-174-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⋅</mo><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>⋅</mo><msup><mi>B</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>a</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>1</mn></msub><mo>⋅</mo><msup><mi>B</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋅</mo><msup><mi>B</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo>⋅</mo><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>⋅</mo><msup><mi>B</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn></mrow></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo>⋅</mo><msub><mi>b</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \cdot b = (a_1 \cdot B^{n/2} + a_0) \cdot (b_1 \cdot B^{n/2} + b_0) = (a_1 \cdot b_1) \cdot B^{n} + (a_0 \cdot b_1 + a_1 \cdot b_0) \cdot B^{n/2} + (a_0 \cdot b_0)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-174">a \cdot b = (a_1 \cdot B^{n/2} + a_0) \cdot (b_1 \cdot B^{n/2} + b_0) = (a_1 \cdot b_1) \cdot B^{n} + (a_0 \cdot b_1 + a_1 \cdot b_0) \cdot B^{n/2} + (a_0 \cdot b_0)</script></li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-175-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><msub><mi>z</mi><mn>2</mn></msub><mo>⋅</mo><msup><mi>B</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msup><mo>+</mo><msub><mi>z</mi><mn>1</mn></msub><mo>⋅</mo><msup><mi>B</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn></mrow></msup><mo>+</mo><msub><mi>z</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">= z_2 \cdot B^{n} + z_1 \cdot B^{n/2} + z_0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-175">= z_2 \cdot B^{n} + z_1 \cdot B^{n/2} + z_0</script></li>
</ul></li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-176-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">B^{n}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-176">B^{n}</script>으로의 곱은 선형시간에 할 수 있다는 점을 감안하면, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-177-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-177">n/2</script> 크기의 정수 곱셈 세 번만 하면 되기 때문에 확실히 빠르다!</li>
</ul>

<h3 id="toc_30">FFT와 다항식 곱셈</h3>

<ul>
<li>빠른 다항식 곱셈 알고리즘이 있으면 긴 정수 곱셈도 빠르게 할 수 있다. 긴 정수를 몇 자리씩 끊어서 다항식의 계수로 삼은 뒤, 두 다항식을 곱하고, 마지막에 올림 처리만 해 주면 되기 때문.</li>
<li>다항식 곱셈 또한 물론 단순한 방법은 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-178-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-178">O(n^2)</script>인데, FFT를 이용하면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-179-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \lg n)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-179">O(n \lg n)</script>에 할 수 있다.</li>
<li>FFT 곱셈은 다항식에 두 가지 표현 방식이 있다는 것을 이용한다:

<ul>
<li>계수 목록 형태: 대부분 사용하는 방식</li>
<li>x, y쌍 형태: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-180-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-180">2n</script>개의 상수 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-181-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>⋯</mo><mo>,</mo><msub><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_0, x_1, \cdots, x_{n-1}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-181">x_0, x_1, \cdots, x_{n-1}</script>에 대해 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-182-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mo stretchy="false">(</mo></msub><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><msub><mi>f</mi><mo stretchy="false">(</mo></msub><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">f_(x_0), f_(x_1), \cdots</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-182">f_(x_0), f_(x_1), \cdots</script>를 저장하는 방식</li>
</ul></li>
<li><span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-183-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-183">n</script>개의 샘플은 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-184-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-184">n</script>차 방정식을 유니크하게 정의하기 때문에 이 두 표현 방식은 동등하다.

<ul>
<li>하지만 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-185-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)\cdot g(x)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-185">f(x)\cdot g(x)</script>를 x, y쌍 형태에서는 그냥 원소별로 곱해주면 된다!</li>
</ul></li>
<li>FFT는 특정 성질을 띠는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-186-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-186">x</script>들을 선택해, 이 두 형태간의 변환을 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-187-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \lg n)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-187">O(n \lg n)</script>에 수행한다.</li>
<li>곱셈 자체는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-188-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-188">O(n)</script>이다.</li>
<li>자세히는 <a href="http://en.wikipedia.org/wiki/read/wookayin">wookayin</a>님의 <a href="http://bit.ly/1j6jhGb">슬라이드</a>를 보자: </li>
</ul>

<p>C++ 구현:</p>
<div class="highlight"><pre><span class="cp">#include&lt;vector&gt;</span>
<span class="cp">#include&lt;complex&gt;</span>
<span class="cp">#include&lt;cmath&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Complex</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Complex</span><span class="o">&gt;</span> <span class="n">ComplexVector</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Polynomial</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">double</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">acos</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>

<span class="c1">// Given a n-th polynomial p, return its values at</span>
<span class="c1">// w^0, w^1, .., w^(n-1). n is assumed to be a power of 2.</span>
<span class="c1">// Since the size of the input and output are the same, the output is stored at</span>
<span class="c1">// p.</span>
<span class="kt">void</span> <span class="nf">dft</span><span class="p">(</span><span class="n">ComplexVector</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="c1">// divide</span>
  <span class="n">ComplexVector</span> <span class="n">even</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">odd</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">even</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
    <span class="n">odd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// conquer</span>
  <span class="n">dft</span><span class="p">(</span><span class="n">even</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="n">w</span><span class="p">);</span> 
  <span class="n">dft</span><span class="p">(</span><span class="n">odd</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="n">w</span><span class="p">);</span>

  <span class="c1">// merge</span>
  <span class="n">Complex</span> <span class="n">w_power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Complex</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">w_power</span> <span class="o">*</span> <span class="n">odd</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">p</span><span class="p">[</span><span class="n">i</span>      <span class="p">]</span> <span class="o">=</span> <span class="n">even</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">even</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">w_power</span> <span class="o">*=</span> <span class="n">w</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// returns smallest power of 2 s.t. p2 &gt;= n.</span>
<span class="kt">int</span> <span class="nf">roundUp</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">p2</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">p2</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">p2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Polynomial</span> <span class="k">operator</span> <span class="o">*</span> <span class="p">(</span><span class="k">const</span> <span class="n">Polynomial</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Polynomial</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// last *2 is needed because C can have twice the degree from original polys</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">roundUp</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">()))</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// Complex representations of a and b</span>
  <span class="n">ComplexVector</span> <span class="nf">ac</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span> <span class="n">bc</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">ac</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> 
  <span class="n">bc</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="c1">// FFT </span>
  <span class="n">Complex</span> <span class="n">w</span> <span class="o">=</span> <span class="n">polar</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">/</span> <span class="n">n</span><span class="p">);</span>
  <span class="n">dft</span><span class="p">(</span><span class="n">ac</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
  <span class="n">dft</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
  <span class="c1">// Pointwise multiplication</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
    <span class="n">ac</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

  <span class="c1">// Inverse FFT</span>
  <span class="n">dft</span><span class="p">(</span><span class="n">ac</span><span class="p">,</span> <span class="n">polar</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">/</span> <span class="n">n</span><span class="p">));</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
    <span class="n">ac</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="kt">double</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="c1">// Trim zero paddings</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">ac</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">fabs</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">ac</span><span class="p">.</span><span class="n">back</span><span class="p">()))</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">)</span> 
    <span class="n">ac</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

  <span class="c1">// return real</span>
  <span class="n">Polynomial</span> <span class="nf">ret</span><span class="p">(</span><span class="n">ac</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ac</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
    <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">round</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">ac</span><span class="p">[</span><span class="n">i</span><span class="p">])));</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h3 id="toc_31">긴 정수 곱셈의 응용</h3>

<h2 id="toc_32">알면 유용한 사실들</h2>

<ul>
<li>약수의 상한: <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-189-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1..</mn><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1..n]</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-189">[1..n]</script>의 범위에 대하여 최대 약수의 개수는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-190-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>3</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1/3})</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-190">O(n^{1/3})</script>으로 어림잡을 수 있다. <a href="http://oeis.org/A066150">OEIS66150</a>을 참고하면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-191-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-191">10^9</script>범위 내에서는 최대 1344개, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-192-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mrow class="MJX-TeXAtom-ORD"><mn>18</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{18}</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-192">10^{18}</script>범위 내에서는 최대 103680개의 약수가 있다. 각각 735134400, 897612484786617600이 그에 해당한다. <a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1748">관련문제</a></li>
<li>원점에서 (a,b)까지 선분 위 격자점의 개수는 gcd(a,b)</li>
<li>pi(x) ~= x/log(x)</li>
<li>2차원에서 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-193-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-193">L_1</script> 길이와 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-194-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi mathvariant="normal">∞</mi></msub></mrow><annotation encoding="application/x-tex">L_\infty</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-194">L_\infty</script> 길이는 45도 돌리고 scaling하면 같게 할 수 있다.</li>
<li>homogenous coordinate system: 한 차원을 추가하고 상수를 곱해서 같게 할 수 있는 것들을 동등하게 보는 것으로 기하를 다룰 수 있다. (<a href="https://algospot.com/forum/read/2980/">관련 글 링크</a>)

<ul>
<li>2차원 기하

<ul>
<li>점 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-195-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-195">(x,y)</script>를 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-196-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mi>x</mi><mo>,</mo><mi>k</mi><mi>y</mi><mo>,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(kx,ky,k)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-196">(kx,ky,k)</script>로 표현하고 직선 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-197-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>+</mo><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">ax+by+c = 0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-197">ax+by+c = 0</script>을 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-198-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b,c)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-198">(a,b,c)</script>로 표현하면 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-199-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>k</mi><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>b</mi><mo stretchy="false">(</mo><mi>k</mi><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a(kx)+b(ky)+c(k) = 0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-199">a(kx)+b(ky)+c(k) = 0</script>, 즉 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-200-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mi>x</mi><mo>,</mo><mi>k</mi><mi>y</mi><mo>,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(kx,ky,k)\cdot(a,b,c)=0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-200">(kx,ky,k)\cdot(a,b,c)=0</script>에서 duality를 얻는다. 점의 경우 세번째 성분이 1이 되도록 어떤 실수를 scalar 곱을 해서 해석하면, 원래 알고 있는 것이 나온다. 예를 들어 (2,4,2)는 (1,2)로 해석하는 식이다. 점을 나타내는 좌표의 세 번째 성분이 0인 경우 무한히 멀리 떨어진 해당 방향의 점으로 여긴다.</li>
<li>점과 직선은 자유롭게 관점을 바꿔보아도 여러 관계가 유지된다. 점과 점을 지나는 직선은 관점을 바꾸어 직선과 직선을 지나는 점이라고 볼 수 있다. 예를 들어 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-201-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,2)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-201">(1,2)</script>과 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-202-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2,3)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-202">(2,3)</script>를 지나는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-203-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>−</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y-x-1=0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-203">y-x-1=0</script>이라는 직선은 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-204-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y+2x+1=0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-204">y+2x+1=0</script>, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-205-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>y</mi><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">2y+3x+1=0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-205">2y+3x+1=0</script>을 지나는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-206-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-1,1)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-206">(-1,1)</script>이라고 여길 수 있다.</li>
<li>위 내적이 있는 식은 수직을 의미하는 관계이므로, 두 점 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-207-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1,y_1)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-207">(x_1,y_1)</script>, <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-208-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_2,y_2)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-208">(x_2,y_2)</script>을 지나는 직선은 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-209-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1, 1) \times (x_2, y_2, 1)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-209">(x_1, y_1, 1) \times (x_2, y_2, 1)</script>로 얻을 수 있다. 예를 들어 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-210-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,2)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-210">(1,2)</script>와 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-211-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2,3)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-211">(2,3)</script>을 지나는 직선은 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-212-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,2,1) \times (2,3,1) = (-1, 1, 1)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-212">(1,2,1) \times (2,3,1) = (-1, 1, 1)</script>에서 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-213-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">-x+y+1=0</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-213">-x+y+1=0</script>을 얻는다. duality에 의해 직선과 직선의 교점도 외적으로 얻는다. 두 점/직선을 교차하는 직선/점이 없거나 무한히 많은 경우 재밌는 결과가 나오므로 직접 확인해보자. </li>
</ul></li>
<li>3차원 기하

<ul>
<li>2차원과 마찬가지로 점 (x,y,z)를 (kx,ky,kz,k)로 표현한다. 그리고 함께 다루는 것은 평면 ax+by+cz+d = 0을 의미하는 (a,b,c,d)이다. 직선은 평면 두 개를 이용해 표현한다.</li>
<li>wedge product를 쓰는 것이 있다.</li>
<li>점/평면 세 개 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-214-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>b</mi><mn>1</mn></msub><mo>,</mo><msub><mi>c</mi><mn>1</mn></msub><mo>,</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mo>⋯</mo><mo>,</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>3</mn></msub><mo>,</mo><msub><mi>b</mi><mn>3</mn></msub><mo>,</mo><msub><mi>c</mi><mn>3</mn></msub><mo>,</mo><msub><mi>d</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_1, b_1, c_1, d_1), \cdots, (a_3, b_3, c_3, d_3)</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-214">(a_1, b_1, c_1, d_1), \cdots, (a_3, b_3, c_3, d_3)</script>의 공통평면/교점은 
<span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-215-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo>|</mo><mtable rowspacing="4pt" columnspacing="1em"><mtr><mtd style="padding: 0px;"><msub><mi>e</mi><mn>1</mn></msub></mtd><mtd style="padding: 0px 0px 0px 1em;"><msub><mi>e</mi><mn>2</mn></msub></mtd><mtd style="padding: 0px 0px 0px 1em;"><msub><mi>e</mi><mn>3</mn></msub></mtd><mtd style="padding: 0px 0px 0px 1em;"><msub><mi>e</mi><mn>4</mn></msub></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><msub><mi>a</mi><mn>1</mn></msub></mtd><mtd style="padding: 4pt 0px 0px 1em;"><msub><mi>b</mi><mn>1</mn></msub></mtd><mtd style="padding: 4pt 0px 0px 1em;"><msub><mi>c</mi><mn>1</mn></msub></mtd><mtd style="padding: 4pt 0px 0px 1em;"><msub><mi>d</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><msub><mi>a</mi><mn>2</mn></msub></mtd><mtd style="padding: 4pt 0px 0px 1em;"><msub><mi>b</mi><mn>2</mn></msub></mtd><mtd style="padding: 4pt 0px 0px 1em;"><msub><mi>c</mi><mn>2</mn></msub></mtd><mtd style="padding: 4pt 0px 0px 1em;"><msub><mi>d</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd style="padding: 4pt 0px 0px;"><msub><mi>a</mi><mn>3</mn></msub></mtd><mtd style="padding: 4pt 0px 0px 1em;"><msub><mi>b</mi><mn>3</mn></msub></mtd><mtd style="padding: 4pt 0px 0px 1em;"><msub><mi>c</mi><mn>3</mn></msub></mtd><mtd style="padding: 4pt 0px 0px 1em;"><msub><mi>d</mi><mn>3</mn></msub></mtd></mtr></mtable><mo>|</mo></mrow></mrow><annotation encoding="application/x-tex">\left| \begin{matrix}
e_1 &amp; e_2 &amp; e_3 &amp; e_4 \\
a_1 &amp; b_1 &amp; c_1 &amp; d_1 \\
a_2 &amp; b_2 &amp; c_2 &amp; d_2 \\
a_3 &amp; b_3 &amp; c_3 &amp; d_3
\end{matrix} \right|</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-215">
\left| \begin{matrix}
e_1 & e_2 & e_3 & e_4 \\
a_1 & b_1 & c_1 & d_1 \\
a_2 & b_2 & c_2 & d_2 \\
a_3 & b_3 & c_3 & d_3
\end{matrix} \right|
</script>로 계산할 수 있다. 여기서 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-216-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-216">e_i</script>는 <span class="mathjax-preview" style="display: none;"></span><span class="MathJax_MathML" id="MathJax-Element-217-Frame"><span class="MathJax_MathContainer" tabindex="-1" style="position: relative; display: inline-block; white-space: nowrap;"><span style="display: inline-block;"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span></span></span><script type="math/tex" id="MathJax-Element-217">i</script>번째 단위 벡터를 나타낸다. 참고: <a href="http://www.cs.iastate.edu/%7Ecs577/handouts/homogeneous-coords-space.pdf">http://www.cs.iastate.edu/~cs577/handouts/homogeneous-coords-space.pdf</a></li>
<li>wedge product 개념을 이용하면 점, 직선, 평면들의 관계를 쉽게 계산할 수 있다.</li>
</ul></li>
</ul></li>
</ul>

		</div>
	</section>


						<!-- Article Footer -->

						<footer>
						</footer>
						<!-- /Article Footer -->

					</div>