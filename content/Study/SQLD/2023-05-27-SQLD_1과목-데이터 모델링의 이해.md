---
title: "[SQLD]1과목-데이터 모델링의 이해"
date: 2023-05-27 17:00:00 +0900
categories:
  - Database
  - SQLD
tags:
  - 자격증
  - SQLD
---


# Part 1. 데이터 모델링의 이해

## 1.1 Modeling
### 데이터 모델링 정의
1. 정보시스템 구축 위한 데이터 관점의 업무 분석기법
2. 현실세계 데이터에 대해 약속된 표기법에 의해 표현하는 과정
3. 데이터베이스 구축하기 위한 분석, 설계과정

### 모델링의 특징

|        | 모델링의 특징|
|--------|---------|
| 추상화 | 현실세계를 일정한 양식, 표기법에 맞추어 표현 (=모형화, 가설적) |
| 단순화 | 복잡한 현실 게계를 약속된 규약에 의해 제한된 표기법이나 언어로 표현|
| 명확화 | 누구나 이해하기 쉽게하기 위해 대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술하는 것 |

### 모델링의 세 가지 관점
1. 데이터 관점: 업무가 어떤 데이터와 관련이 있는지, 데이터간 관계 무엇인지 (What, Data)
2. 프로세스 관점: 업무가 실제하고 있는 일 무엇인지, 무엇을 해야하는지 (How, Process)
3. 상관 관점: 업무 처리하는 방법에 따라 데이터 어떻게 영향 받고 있는지 (Interaction)

### 데이터 모델리의 중요성
- 파급효과가 크다(Leavarage)
- 복잡한 정보 요구사항의 간결한 표현(Conciseness)
- 데이터 품질을 유지 (Data Quality)

### 데이터 모델링의 유의점

|  | 데이터 모델링의 중요성 및 유의점 |
|---|---|
| 중복 | 같은 시간 같은 데이터 제공 |
| 비유연성 | 사소한 업무변화에 데이터 모델이 수시로 변경되면 안됨 |
| 비일관성 | 신용 상태에 대한 갱신 없이 고객의 납부 이력 정보 갱신 안됨(연계성↓) |

### 데이터 모델링의 3단계 진행
(추상적)개념적 -> 논리적 -> 물리적(구체적)

 |  | 개념-논리-물리 데이터 모델 |
|---|---|
| 개념적 데이터 모델링 | 추상화 수준이 높고 업무중심적이고 포관적인 수준의 모델링 진행.전사적 데이터 모델링, EA수립시 많이 적용|
| 논리적 데이터 모델링 | 시스템으로 구축하고자 하는 업무에 대해 Key, 속성, 관계 등을 정확하게 표현, 재사용성이 높음 |
| 물리적 데이터 모델링 | 실제로 데이터베이스에 이식 할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계 |

### 데이터 독립성

|	| 데이터 독립성 |
|---|---|
| 논리적 독립성 | 개념 스키마가 변경되어도 외부 스키마에 영향 x |
| 물리적 독립성 | 내부 스키마가 변경되어도 외부/개념 스키마는 영향 x |

> #### 독립성이 필요한 이유
유지보수 비용 증가, 데이터 중복성, 복잡성 증가, 요구사항 대응 저하

### Mapping(사상):

상호 독립적인 개념을 연결시켜주는 다리

논리적 사상: 외부 스키마 - 개념 스키마
물리적 사상: 개념 스키마 - 내부 스키마

### 데이터 모델링의 3요소
1. 어떤 것(Things) 
2. 성격(Attributes)
3. 관계(Relationships)

### 모델링의 특징
1. 추상화
2. 단순화
3. 정화화
![](https://velog.velcdn.com/images/syshin0116/post/a8b583b6-1e77-43bb-9700-bc96671f129c/image.png)

### 데이터 모델 표기법
1976년 피터첸이 Entity Relationship Model 개발 

- IE, Baker 기법이 많이 쓰임
- 엔터티, 관계, 속성으로 이뤄짐

### ERD 작업순서
1. 엔터티 그림 
2. 엔터티 배치 
3. 엔터티 관계설정 
4. 관계명 기술 
5. 관계의 참여도 기술 
6. 관계필수여부 기술
![](https://velog.velcdn.com/images/syshin0116/post/32a91a8b-6ed3-436f-9abb-1c6ae6bc76a8/image.png)

### 좋은 데이터 모델의 요소

1. 완전성 : 업무에 필요한 모든 데이터가 모델에 정의
2. 중복배제 : 하나의 DB내에 동일한 사실은 한번만. 
3. 업무규칙 : 많은 규칙을 사용자가 공유하도록 제공 
4. 데이터 재사용 : 데이터가 독립적으로 설계돼야 함 
5. 의사소통 : 업무규칙은 엔터티, 서브타입, 속성, 관계 등의 형태로 최대한 자세히 표현
6. 통합성 : 동일한 데이터는 한번만 정의, 참조 활용

## 1.2 Entity
### 엔터티란?
- 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것, 보이지 않는 개념을 포함한다
- 명사에 해당, 저장이 되기 위한 어떤 것(Thing)
![](https://velog.velcdn.com/images/syshin0116/post/8f16884c-2b72-49cb-97fd-4499366c6e85/image.png)

### 엔터티의 특징

1. 업무에서 필요하고 관리해야 함 
2. 유일한 식별자에 의해 식별 가능
3. 두 개 이상의 인스턴스의 집합
4. 업무 프로세스에 의해 이용되어야 함
5. 반드시 속성이 있어야 함 (예외적으로 관계엔터티의 경우 는 주식별자 속성만 가지고 있어도 엔터티로 인정)
6. 다른 엔터티와 최소 1개 이상의 관계가 있어야 함 (통계성/코드성 엔터티, 시스템 처리시 내부 필요에 의한 엔터티 도출과 같은 경우 관계 생략 가능)

### 엔터티의 분류
#### 유무형에 따른 분류
1. 유형: 물리적 형태(안정적, 지속적)
ex) 사원, 물품, 강사
2. 개념: 개념적 정보
ex) 조직, 보험상품
3. 사건: 업무수해잇 발생(통계자료 이용)
ex) 주문, 청수, 미납

>- 유형: Tangible Entity
- 개념: Conceptual Entity
- 사건: Event Entity

#### 발생시점에 따른 분류
발생시점: 기본 -> 중심 -> 행위

1. 기본: 그 업무에 원래 존재하는 정보, 타 엔터티의 부모 역할, 자신의 고유한 주식별자 가짐
ex) 사원, 부서
2. 중심: 기본 엔터티로부터 발생, 다른 엔터티와의 관계로 많은 행위 엔터티 생성
ex) 계약, 사고, 주문
3. 행위: 2개 이상의 부모 엔터티로부터 발생, 자주 바뀌거나 양이 증가
ex) 주문목록, 사원변경이력

![](https://velog.velcdn.com/images/syshin0116/post/a53ffd35-169e-4ae4-8ecc-7a463c86ad6c/image.png)


### 엔터티의 명명
현업업무에서 사용하는 용어 사용, 약어 사용금지, 단수명사 사용, 고유한 이름 사용, 생성의미대로 부여

## 1.3 Attributes
### 속성
- 업무에서 필요
- 인스턴스의 구성요소
- 의미상 분리되지 않는 최소의 데이터 단위

### 인스턴스 - 속성 - 엔터티의 관계
- 한 개의 엔터티는 2개 이상의 인스턴스 집합
- 한 개의 엔터티는 2개 이상의 속성을 가짐
- 한 개의 속성은 1개의 속성값을 가짐

### 구성 방식의 분류:
Primary Key, Foreign Key, 일반속성

### 속성의 분류
1. 기본: 업무로부터 추출한 모든 일반적인 속성_원래 속성
2. 설계: 업무를 규칠과하기 위해 새로 만들거나 변형, 정의하는 속성
ex) 일련변호
3. 파생: 달른 속성에 영향을 받아 발생하는 속성, 빠른 성능을 낼 수 있도록 원래 속성의 값을 계산
ex) 합

### 도메인
속성에 대한 데이터 타입, 크기(범위), 제약사항 지정

### 속성의 명명
1. 해당업무에서 사용하는 이름 부여
2. 서술식 속성명은 사용 금지
3. 약어 사용 금지
4. 전체 데이터모델에서 유일성 확보

## 1.4 Relationship

### 관계
엔터티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태, 관계 페어링의 집합

ex) 강사 - 가르친다(관계) - 수강생

- 존재의 의한 관계 ex) 소속된다
- 행위에 의한 관계 ex) 주문한다

### 페어링
엔터티 안에 인스턴스가 개별적으로 관계를 가지는 것

### UML(통합모델링언어)에서의 관계
1. 연관관계(실선): 항상 이용하는 관계 ex) 소속된다
2. 의존관계(점선): 상대 행위에 의해 발생하는 관계 ex) 주문한다

### 관계의 표기법
관계명(Membership): 관계의 이름
관계차수(Cardinality): 1:1, 1:M, M:N
관계선택성(Optionality): 필수관계, 선택관계

### 관계 체크사항
1. 엔터티 간에 연관 규칙이 존재하는가?
2. 엔터티 간에 정보의 조합이 발생되는가?
3. 업무 기술서, 장표에 관계연결에 대한 규칙이 서술되어있는가?
4. 업무기술서, 장표에 관계연결을 가능케 하는 동사가 있는가?

## 1.5 Identifier

### 식별자
- 엔터티 내에서 인스턴스를 구분하는 구분자
- 식별자는 논리적, Key는 물리적 데이터 모델링 단계에 사용

### 식별자의 특징

|  | 식별자의 특징 |
|---|---|
| 유일성 | - 주식별자에 의해 모든 인스턴스들이 유일하게 구분 |
| 최소성 | - 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다 |
| 불변성 | - 지정된 주식별자의 값은 자주 변하지 않아야 한다. 변하면 이전 기록 말소 |
| 존재성 | - 주식별자가 지정되면 반드시 값이 들어와야 한다 |

### 식별자 분류

<table>
  <thead>
    <tr>
      <th colspan=3 style="text-align:center" >식별자 분류</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan = 3>대표성 여부</th>
    </tr>
    <tr>
      <td>주 식별자</td>
      <td>엔터티 내에서 각 어커런스를 구분할 수 있는 구분자, 타 엔터티와 참조관계를 연결</td>
    </tr>
    <tr>
      <td>보조식별자</td>
      <td>구분자지만 대표성 X, 참조관계 연결 X</td>
    </tr>
    <tr>
      <th rowspan=3>스스로 생성여부</th>
    </tr>
    <tr>
      <td>내부식별자</td>
      <td>스스로 생성되는 식별자</td>
    </tr>
    <tr>
      <td>외부식별자</td>
      <td>타 엔터티로부터 받아오는 식별자</td>
    </tr>
    <tr>
      <th rowspan=3>속성의 수</th>
    </tr>
    <tr>
      <td>단일식별자</td>
      <td>하나의 속성으로 구성</td>
    </tr>
    <tr>
      <td>복합식별자</td>
      <td>2개 이상의 속성으로 구성</td>
    </tr>
    <tr>
      <th rowspan=3>대체 여부</th>
    </tr>
    <tr>
      <td>본질</td>
      <td>업무에 의해 만들어지는 식별자</td>
    </tr>
    <tr>
      <td>인조</td>
      <td>인위적으로 만든 식별자</td>
    </tr>
  </tbody>
</table>

### 주식별자 도출기준
1. 해당 업무에서 자주 이용되는 속성임
2. 명칭, 내역 등과 같이 이름으로 기술되는 것들은 X
3. 복삽으로 주식별자로 구성할 경우 너무 많은 속성 X
	-> 너무 많으면 인조식별자 생성

### 식별자 관계

**주식별자** : 자식의 주식별자로 부모의 주식별자 상속

- 부모로부터 받은 식별자를 자식엔터티의 주식별자로 이용하는 경우
- 강한 연결관계 표현. 실선 표기
- 식별자 관계로만 설정 시 주식별자 증가로 오류 유발

**비실별자**: 부모 속성을 자식의 일반 속성으로 사용

1. 부모 없는 자식이 생성될 수 있는 경우
2. 부모와 자식의 생명주기가 다른 경우 (별도로소멸) 
3. 여러개의 엔터티가 하나의 엔터티로 통합되어 표현되었는데 각각의 엔터티가 별도의 관계를 가진 경우
4. 자식엔터티에 별도의 주식별자를 생성하는 것이 더 유리한 경우
5. SQL 문장이 길어져 복잡성 증가되는 것 방지

- 약한 연결관계 표현, 점선 표기
- 비식별자 관계로만 설정 시 부모 엔터티와 조인하여 성능 저하

> 주식별자/비식별자 관계는 상속여부가 핵심
#### 비식별자 관계 설정 고려사항:
관계분석 -> 관계의 강/약 분석(약) -> 자식테이블 독립 PK 필요(필요) -> SQL 복잡도 증가(비식별자)
#### 식별자 관계설정 고려사항:
강한관계, 주식별자 PK 사용

>#### 주식별자의 특징
- 유일성 : 주식별자에 의해 엔터티내에 모든 인스턴스들을 **유일**하게 구분할 수 있다. 
- 최소성 : 주식별자를 구성하는 속성의 수는 유일성을 만족하는 **최소의 수**가 되어야 함. 
- 불변성 : 주식별자가 한 번 특정 엔터티에 지정되면 그 식별자의 값은 **변하지 않아야 함**. 
- 존재성 : 주식별자가 지정되면 **반드시 데이터 값이 존재**해야한다. Null은 허용되지 않는다.
#### Q. 주식별자를 지정할 때 고려해야 할 사항은?
1. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다.
2. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
3. 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
4. 주식별자가 지정되면 반드시 값이 들어와야 한다.

> #### 주식별자 / 보조식별자
대표성 여부를 따지는 식별자는 주식별자 / 보조식별자가 있다. 식별자는 대표성, 유니크성을 가지느냐에 따라 결정된다. 보조식별자는 그렇지 못한다.

> #### 내부식별자 / 외부식별자
스스로 생성이 가능한지의 여부에 따라 구분되는 식별자도 있다. 내부식별자는 스스로 생성이 되지만 외부식졀자는 타 엔터티로부터 받아온다. 그래서 ERD 도식을 보면 속성 옆에 (FK)라고 붙은게 가끔 보이는데 이건 Foreign 라고 해서 외부로부터 값을 받아오는거라 (FK)가 붙은애는 외부식별자에 해당한다.
- 따라서 (FK)가 없다면 모두 내부식별자다.

> #### 비식별자?
식별자관계는 주식별자에 종속되는 것이었다면 비식별자는 그렇지 않다. 
- 비식별자는 '**약한 연결관계**이고, 부모엔터티와 자식엔터티 간에 상호작용이 의무가 아닌 **선택사항**이다'

# Part 2. 데이터 모델과 성능

## 2.1 Modelling

### 성능 데이터 모델링
**성능 데이터 모델링**: DB 성능 향상을 목적으로 설계단꼐의 데이터 모델링 때부터 정규화, 반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등 여러가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것

- 분석/설계 단계에서 데이터 모델에 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따른 재업무 비용을 최소화 할 수 있다
- 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용은 기하급수적으로 증가

### 성능 데이터 모델링 고려사항 순서
1. 데이터 모델링을 할 때 정규화를 정확하게 수행
2. DB 용량산정을 수행한다
3. DB에 발생되는 트랜잭션의 유형을 파악한다
4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행
5. 이력모델, PK/FK, 슈퍼/서프타입 조정
6. 성능관점에서 데이터 모델을 검증

>#### 반정규화란?
- 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다.
- 반정규화는 조회(select) 속도를 향상시키지만, 데이터 모델의 유연성은 낮아진다.
#### 반정규화를 수행하는 이유
- 정규화에 충실하여 종속성, 활용성은 향상 되었지만 수행속도가 느려진 경우
- 다량의 범위를 자주 처리해야하는 경우
- 특정 범위의 데이터만 자주 처리하는 경우
- 요약/집계 정보가 자주 요구되는 경우

### 함수적 종속성
데이터들이 어떤 기준 값에 의해 종속되는 현상

### 정규화
반복적인 데이터를 분리하고 각 데이터가 종속된 테이블에 적절하게 배치되도록 하는 작업
- 수행시 데이터 처리(DML) 성능 향상, 조회는 향상 또는 저하될 수 있다

|	| 정규화 |
|---|---|
| 1차 정규화 | 같은 성격, 내용 컬럼이 연속될 때 컬럼 제거, 테이블 생성 |
| 2차 정규화 | PK 복합키 구성일 때 부분적 함수, 종속 관계 테이블 분리 |
| 3차 정규화 | PK가 아닌 일반 컬럼에 의존하는 컬럼 분리 |

> **제1 정규화**: 테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것이다.
**제2 정규화**: 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다. 여기서 완전 함수 종속이라는 것은 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다.
**제3 정규화**: 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다. 여기서 이행적 종속이라는 것은 A -> B, B -> C가 성립할 때 A -> C가 성립되는 것을 의미한다.

### 반정규화
정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법

조회 시 디스크 I/O가 많거나 경로가 멀어 조인에 의한 성능 저하를 막기 위해 수행

일반적으로 정규화시 입력/수정/삭제 성능이 향상되며 반정규화시 조인 성능이 향상된다

### 반정규화 절차
#### 1. 반정규화 대상조사(범위처리빈도수, 범위, 통계성)
1. 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고 항상 일정한 범위만을 조회하는 경우
2. 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우에 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없는 경우
3. 통계성 프로세스에 의해 통계 정보를 필요로 할 때 별도의 통계테이블을 생성한다
4. 테이블에 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우

#### 2. 다른 방법유도 검토(뷰, 클러스터링, 인덱스 조정)
1. VIEW 사용: 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 VIEW를 사용한다. (VIEW 성능향상 X)
2. 클러스터링: 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우 클러스터링을 적용하거나 인덱스를 조정함 (조회가 대부분일 때 클러스터링 적용)
3. 파티셔닝: 대량의 데이터는 PK의 성격에 따라 부분적인 테이블로 분리할 수 있다. 파티셔닝 키에 의해 물리적 저장공간 분리
4. 캐시: 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다

#### 3. 반정규화 적용

#### 3.1 테이블 반정규화
#### 테이블 병합(1:1관계, 1:M관계, 슈퍼/서브타입)
1. 1:1 관계를 통합하여 성능 향상
2. 1:M 관계를 통합하여 성능 향상
3. 슈퍼/서브 관계를 통합하여 성능 향상

#### 테이블 분할(수직분할, 수평분할)
1. 수직분할: 칼럼단위 테이블을 디스크 I/O를 분산처리하기 위해 테이블을 1:1로 분리하여 성능향상
2. 수평분할: 로우단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상하기 위해 로구단위로 테이블을 쪼갬

#### 테이블 추가
1. 중복: 다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능 향상
2. 통계: SUM, AVG 등을 미리 수행하여 계산해둠으로써 조회 시 성능을 향상
3. 이력: 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재시켜 성능 향상
4. 부분: 하나의 테이블의 전체 칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때 디스크 I/O 를 줄이기 위해 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블을 생성

#### 3.2 칼럼 반정규화
1. 중복칼럼 추가: 조인에 의해 처리할 때 성능저하를 예방하기 위해 종복된 칼럼을 위치시킴
2. 파생컬럼 추가: 프랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리 값을 계산하여 칼럼에 보관
3. 이력테이블 칼럼추가: 대량의 이력데이터를 처리할 때 불특정 날 조회나 최근 값을 조회할 때 나타낼 수 있는 성능저하를 예방하기 위해 이력테이블에 기능성 칼럼(최근값 여부, 시작과 종료일자 등)을 추가
4. 응용시스템 오작동을 위한 컬럼 추가: 업무적으로는 의미가 없지만 사용자의 실수로 원래 값으로 복구하기 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법
5. PK에 의한 컬럼 추가: 단일 PK 안에서 특정 값을 별도로 조회하는 경우 성능 저하 발생할 수 있어 일반속성으로 추가

#### 3.3 관계 반정규화: 무결성 유지
중복관계 추가: 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 간으하지만 이 떄 발생할 수 잇는 성능저하를 예방하기 위해 추가적인 관계를 맺는 방법

## 2.2 Row

### 로우 체이닝, 로우 마이그레이션
**로우 체이닝**: 로우의 길이가 긴 경우 두개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
**로우 마이그레이션**: 데이터블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식

> - 로우 체이닝과 로우 마이그레이션이 발생하여 많은 블록에 데이터가 저장되면 DB 메모리에서 디스크 I/O가 발생할 때 성능저하가 발생한다
- 트랜잭션을 분석하여 적절하게 1:1 관계로 분리함으로써 성능 향상이 가능하도록 해야 한다

### PK에 의해 테이블을 분할하는 방법(파티셔닝)
1. RANGE PARTITION: 대상 테이블이 날짜 또는 숫자값으로 분리되는 경우 
2. LIST PARTITION: 지점, 사업소 등 핵심적인 코드값으로 PK가 구성되어 있고 대량의 데이터가 있는 테이블의 경우
3. HASH PARTITION: 지정된 HASH 조건에 따라 해시 알고리즘이 적용되어 테이블이 분리

### 테이블에 대한 수평/수직 분할의 절차
1. 데이터 모델링을 완성한다.
2. DB 용량산정을 한다.
3. 대량 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴을 분석한다.
4. 칼럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는지 분석하여 집중화된 단위로 테이블을 분리하는 것을 검토한다.
- 컬럼 많음 -> 1:1 분리
- 데이터 많음 -> 파티셔닝

## 2.3 

### 슈퍼/서브 타입 모델:
업무를 구성하는 데이터를 공통과 차이점의 특징을 고려하여 효과적 표현
- 논리적 모델
	- 슈퍼 타입: 공통 부분
    - 서브 타입: 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성

### 슈퍼/서브 타입 데이터 모델의 변환기술
1. 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성(OneToOne Type)
2. 슈퍼+서브타입에 발생되는 트랜잭션에 대해서는 슈퍼+서브타입 테이블로 구성(Plus Type)
3. 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성(Single Type, All in One Type)

### 인덱스 특성을 고려한 PK/FK DB 성능향상
- 인덱스의 특징은 여러개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 좋은 효율을 나타냄
- 앞쪽에 위치한 속성의 값이 가급적 '=' 아니면 최소한 범위 'BETWEEN' '<>'가 들어와야 효율적

## 2.4 Distributed Database

### 분산 DB
1. 여러 곳으로 분산되어있는 DB를 하나의 가상 시스템으로 사용할 수 있도록 한 DB
2. 논리적으로 동일한 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터집합

### 분산 DB를 만족하기 위한 6가지 투명성
1. 분할 투명성(단편화): 
	- 하나의 논리적 Relation이 여러 단편으로 분할되어 각 사본이 여러 site에 저장
2. 위치 투명성: 
	- 사용하려는 데이터의 저장 장소 명시 불필요
	- 위치정보가 시스템 카탈로그에 유지
3. 지역사상 투명성:
	- 지역 DBMS와 물리적 DB 사이의 Mapping 보장
4. 중복 투명성:
	- DB 객체가 여러 site에 중복되어 있는지 알 필요 없는 성질
5. 장애 투명성:
	- 구성요소의 장애에 무관한 트랜잭션의 원자성 유지
6. 병행 투명성:
	- 다수 트랜잭션 동시 수행시 결과의 일관성 유지, TimeStamp, 분산 2단계 Locking 이용
    
### 분산 DB 장단점

| 장점 | 단점 |
|--------------|-------------|
| - 비용절감 | - 비용 증가 |
| - 신뢰성, 가용성, 효용성, 융통성 | - 오류의 잠재성 증대 |
| - 빠른 응답속도 | - 불규칙한 응답 속도 |
| - 지역 자치성 | - 설계 관리의 복잡성 -> 통제의 어려움 |
| - 각 지역 사용자 요구 수용 | - 데이터 무결성 위협  |

### 분산 DB 적용 기법
1. 테이블 위치 분산: 설계된 테이블을 본사와 지사단위로 분산, 위치별 DB문서 필요
2. 테이블 분할 분산: 각각의 테이블을 쪼개어 분산
	- 수평분할: 로우 단위로 분리, 지사별로 다를때 중복X
    - 수직분할: 칼럼 단위로 분리, 각 테이블에 동일 PK 존재할 경우

3. 테이블 복제 분산: 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형 
	- 부분복제: 마스터 DB에서 테이블의 일부의 내용만 다른 지역이나 서버에 위치
    - 광역복제: 마스터 DB 테이블의 내용을 각 지역이나 서버에 존재
    
4. 테이블 요약 분산: 지역 간에 또는 서버 간에 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우
	- 분석요약: 동일한 테이블 구조를 가지고 있으면서 분산되어 있는 동일한 내용의 데이터를 이용하여 통합된 데이터를 산출하는 방식 
    ex) 판매실적 지사A, 지사B
    - 통합요약: 분산되어 있는 다른 내용의 데이터를 이용하여 통합된 데이터를 산출하는 방식
    ex) 판매실적 지사 A:C제 품, 지사 B:D 제품
    
### 분산 DB 설계를 고려해야 하는 경우
1. 성능이 중요한 사이트
2. 공통코드, 기준정보, 마스터 데이터의 성능향상
3. 실시간 동기화가 요구되지 않는 경우, Near Real Time 특징을 가지고 있는 경우
4. 특정 서버에 부하가 집중되어 부하를 분산
5. 백업 사이트 구성하는 경우